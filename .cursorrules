# IMPORTANT Write the code as if the guy in charge of maintaining your code is a violent psychopath who knows where you live.

# Cursor AI Rules - Complete Error Prevention System + UI/UX Design Preservation

## üé® CRITICAL: UI/UX DESIGN PRESERVATION PROTOCOL

### MANDATORY PRE-DESIGN RESEARCH
Before creating ANY new UI components, screens, or design elements:

1. **ALWAYS conduct comprehensive design audit first** using research tools
2. **NEVER create custom designs** without verifying no existing patterns exist
3. **ALWAYS use existing design systems, templates, and components**
4. **PRESERVE existing UI/UX patterns** and maintain design consistency
5. **RESEARCH existing design files** before any UI-related modifications

### UI/UX DESIGN HIERARCHY RULES

#### üö® MANDATORY DESIGN RESEARCH SEQUENCE:
1. **Design System Audit** - Check for existing design system files
2. **Component Library Review** - Verify existing UI components
3. **Template Analysis** - Identify reusable templates and patterns
4. **Style Guide Inspection** - Review colors, typography, spacing
5. **Screen Pattern Review** - Analyze existing screen layouts
6. **Only then** - Create new designs if absolutely nothing exists

#### ‚ùå FORBIDDEN DESIGN ACTIONS:
- Creating new UI components without checking existing ones first
- Designing custom layouts when templates exist
- Using arbitrary colors, fonts, or spacing without checking design system
- Creating new navigation patterns when existing ones are available
- Implementing custom animations without reviewing existing motion patterns
- Building new form designs when form templates exist
- Creating new card/list designs when existing patterns are available
- Using random icon sets instead of checking existing icon library
- Implementing custom loading states when existing ones are available
- Creating new modal/popup designs without checking existing patterns

#### ‚úÖ REQUIRED DESIGN RESEARCH ACTIONS:

##### 1. **Design System File Discovery:**
```
Before ANY UI work:
- Use file_search to find: design-system.*, theme.*, styles.*, tokens.*
- Use list_dir to check: /design/, /styles/, /theme/, /ui/, /components/
- Use read_file to examine: tailwind.config.*, styled-components themes
- Search for: colors.*, typography.*, spacing.*, breakpoints.*
```

##### 2. **Component Library Audit:**
```
Before creating components:
- Use file_search to find: /components/, /ui/, /shared/, /common/
- Check for: Button.*, Input.*, Card.*, Modal.*, Navigation.*
- Use read_file to examine existing component implementations
- Verify: props, styling patterns, state management approaches
- Check for: styled-components, Tailwind classes, CSS modules
```

##### 3. **Template Pattern Analysis:**
```
Before designing screens:
- Use file_search to find: /templates/, /layouts/, /screens/, /pages/
- Check for: layout components, screen templates, page structures
- Use read_file to examine: header/footer patterns, navigation layouts
- Verify: responsive patterns, grid systems, container structures
- Look for: master layouts, template components, screen scaffolding
```

##### 4. **Style Guide Verification:**
```
Before applying styles:
- Search for: colors, palette, brand, guidelines, style-guide
- Use read_file to examine: CSS variables, theme objects, color constants
- Check for: typography scales, spacing systems, elevation/shadows
- Verify: animation/transition patterns, responsive breakpoints
- Look for: brand guidelines, design token files
```

##### 5. **Icon and Asset Discovery:**
```
Before using icons/images:
- Use file_search to find: /icons/, /assets/, /images/, IconComponents
- Check for: icon libraries, SVG collections, image assets
- Verify: existing icon naming conventions, size variants
- Look for: brand assets, logos, illustration patterns
```

### DESIGN CONSISTENCY ENFORCEMENT

#### Pattern Matching Requirements:
```typescript
// ‚úÖ GOOD - Use existing component patterns
// Step 1: Found existing Button component via file_search
import { Button } from '@/components/ui/Button';
import { Card } from '@/components/ui/Card';

// Step 2: Match existing styling patterns
<Card className="bg-white shadow-md rounded-lg p-6">
  <Button variant="primary" size="lg">
    Continue
  </Button>
</Card>

// ‚ùå BAD - Creating custom designs without research
<div style={{
  backgroundColor: '#ff0000', // Random color
  padding: '20px',           // Custom spacing
  borderRadius: '5px'        // Custom radius
}}>
  <button style={{
    backgroundColor: '#00ff00', // Random color
    padding: '10px 20px'       // Custom padding
  }}>
    Continue
  </button>
</div>
```

#### Color System Adherence:
```typescript
// ‚úÖ GOOD - Use existing color system
// Step 1: Found theme colors via read_file of theme.ts
const colors = {
  primary: '#3B82F6',    // From existing theme
  secondary: '#6B7280',  // From existing theme
  success: '#10B981',    // From existing theme
}

// ‚ùå BAD - Random color choices
const colors = {
  primary: '#ff5733',    // Random color
  secondary: '#c70039',  // Not from design system
  success: '#900c3f',    // Inconsistent with brand
}
```

#### Typography Consistency:
```typescript
// ‚úÖ GOOD - Use existing typography system
// Step 1: Found typography scale via read_file of styles
<Text className="text-lg font-semibold text-gray-900">
  Heading
</Text>
<Text className="text-base text-gray-600">
  Body text
</Text>

// ‚ùå BAD - Custom typography without system
<Text style={{
  fontSize: 22,           // Random size
  fontWeight: '700',      // Custom weight
  color: '#123456'        // Random color
}}>
  Heading
</Text>
```

### COMPONENT REUSE ENFORCEMENT

#### Mandatory Component Discovery Process:
```
1. Search existing components: file_search "Button" "Card" "Input" "Modal"
2. Read component implementations: read_file for each found component
3. Analyze component APIs: props, variants, styling options
4. Check for composition patterns: how components work together
5. Verify accessibility patterns: existing a11y implementations
6. Only create new if gap identified and documented
```

#### Component Extension vs Creation:
```typescript
// ‚úÖ GOOD - Extend existing component
// Step 1: Found existing Button via research
import { Button } from '@/components/ui/Button';

// Step 2: Extend with new variant if needed
<Button variant="outline" size="sm" icon="plus">
  Add Item
</Button>

// ‚ùå BAD - Create new button without checking existing
const CustomButton = styled.TouchableOpacity`
  background-color: #3B82F6;
  padding: 12px 24px;
  border-radius: 8px;
`;
```

### LAYOUT TEMPLATE PRESERVATION

#### Screen Layout Research Protocol:
```
Before designing any new screen:
1. Use file_search to find: /layouts/, /templates/, /screens/
2. Use list_dir to examine: app structure, navigation patterns
3. Use read_file to analyze: existing screen implementations
4. Check for: header patterns, navigation structures, content layouts
5. Verify: responsive patterns, safe area handling, platform differences
6. Document: any gaps in existing templates before creating new
```

#### Template Hierarchy Respect:
```typescript
// ‚úÖ GOOD - Use existing layout template
// Step 1: Found ScreenTemplate via research
import { ScreenTemplate } from '@/components/templates/ScreenTemplate';
import { Header } from '@/components/layout/Header';

export default function NewScreen() {
  return (
    <ScreenTemplate
      header={<Header title="New Screen" showBack />}
      scrollable
      padding="lg"
    >
      {/* Content using existing components */}
    </ScreenTemplate>
  );
}

// ‚ùå BAD - Create custom layout without checking templates
export default function NewScreen() {
  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <View style={{ height: 60, backgroundColor: '#f0f0f0' }}>
        {/* Custom header */}
      </View>
      <ScrollView style={{ padding: 16 }}>
        {/* Custom content */}
      </ScrollView>
    </View>
  );
}
```

### DESIGN RESEARCH DOCUMENTATION

#### Required Research Documentation:
```typescript
// MANDATORY: Document design research in comments
/*
DESIGN RESEARCH COMPLETED:
‚úÖ Checked /components/ui/ - Found Button, Card, Input components
‚úÖ Checked /styles/theme.ts - Found color system and typography
‚úÖ Checked /templates/ - Found ScreenTemplate and FormTemplate
‚úÖ Analyzed existing patterns - Header, navigation, form layouts
‚ùå No existing loading spinner component found
‚úÖ DECISION: Creating LoadingSpinner as no existing pattern found

REUSED COMPONENTS:
- Button (variant="primary")
- Card (shadow="md") 
- ScreenTemplate (padding="lg")

NEW COMPONENTS JUSTIFIED:
- LoadingSpinner: No existing loading pattern found after thorough search
*/

import { Button } from '@/components/ui/Button';
import { Card } from '@/components/ui/Card';
import { ScreenTemplate } from '@/components/templates/ScreenTemplate';
// Only create LoadingSpinner after research confirmed no existing pattern
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'; // JUSTIFIED
```

### STYLE SYSTEM INTEGRATION

#### CSS/Styling Pattern Adherence:
```typescript
// ‚úÖ GOOD - Use existing styling patterns
// Step 1: Found existing styling approach via read_file
import { styles } from '@/styles/commonStyles';
import { colors } from '@/styles/colors';

const componentStyles = StyleSheet.create({
  container: {
    ...styles.cardBase,        // Reuse existing pattern
    backgroundColor: colors.surface, // Use design tokens
    marginBottom: styles.spacing.md, // Use spacing system
  },
});

// ‚ùå BAD - Custom styles without checking system
const componentStyles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',  // Hardcoded color
    padding: 16,                // Custom spacing
    borderRadius: 8,            // Custom radius
    shadowOffset: { width: 0, height: 2 }, // Custom shadow
  },
});
```

### RESPONSIVE PATTERN PRESERVATION

#### Breakpoint System Discovery:
```
Before implementing responsive design:
1. Search for: breakpoints, responsive, media, screen
2. Check for: existing responsive utilities, grid systems
3. Verify: how existing components handle different screen sizes
4. Look for: platform-specific patterns (iOS/Android differences)
5. Use existing responsive patterns before creating new ones
```

#### Responsive Implementation Consistency:
```typescript
// ‚úÖ GOOD - Use existing responsive patterns
// Step 1: Found responsive utilities via research
import { useResponsive } from '@/hooks/useResponsive';
import { breakpoints } from '@/styles/breakpoints';

const { isTablet, isMobile } = useResponsive();

// Step 2: Use existing responsive patterns
<View style={[
  styles.container,
  isTablet && styles.containerTablet,
  isMobile && styles.containerMobile
]}>

// ‚ùå BAD - Custom responsive without checking existing
const screenWidth = Dimensions.get('window').width;
<View style={{
  padding: screenWidth > 768 ? 24 : 16, // Custom breakpoint
  flexDirection: screenWidth > 768 ? 'row' : 'column' // Custom logic
}}>
```

### ANIMATION AND MOTION CONSISTENCY

#### Animation Pattern Discovery:
```
Before adding animations:
1. Search for: animation, transition, motion, spring, timing
2. Check for: existing animation utilities, transition patterns
3. Verify: brand motion guidelines, timing curves, easing functions
4. Look for: loading animations, page transitions, micro-interactions
5. Use existing motion patterns for consistency
```

### ACCESSIBILITY PATTERN PRESERVATION

#### A11y Research Requirements:
```
Before implementing accessibility:
1. Check existing components for: accessibility patterns
2. Verify: screen reader support, focus management, color contrast
3. Look for: existing a11y utilities, testing patterns
4. Use: established accessibility patterns before creating new
5. Maintain: consistent accessibility experience
```

### DESIGN VALIDATION CHECKLIST

Before ANY UI/UX implementation:
- [ ] **Design system files researched** (colors, typography, spacing)
- [ ] **Component library audited** (existing UI components found)
- [ ] **Template patterns analyzed** (layout and screen templates)
- [ ] **Style guide reviewed** (brand guidelines, patterns)
- [ ] **Icon library checked** (existing icon systems)
- [ ] **Animation patterns discovered** (motion and transitions)
- [ ] **Responsive patterns verified** (breakpoints, grid systems)
- [ ] **Accessibility patterns confirmed** (a11y implementations)
- [ ] **Research documented** (what was found vs what needs creation)
- [ ] **Existing patterns reused** (maximum component/pattern reuse)
- [ ] **New designs justified** (documented why new creation needed)
- [ ] **Design consistency maintained** (follows established patterns)

## üö® CRITICAL: EXPO BUNDLING ERROR PREVENTION

### MANDATORY PRE-EDIT CHECKS
Before making ANY code changes that involve imports or file references:

1. **ALWAYS verify file structure first** using `list_dir` or `file_search` tools
2. **NEVER assume import paths exist** without checking
3. **ALWAYS use correct relative paths** based on actual file locations
4. **TEST import paths** against the real directory structure
5. **CHECK if target files have actual content** before referencing them

### IMPORT PATH RULES

#### ‚ùå FORBIDDEN ACTIONS:
- Adding imports without verifying the target file exists AND has content
- Using relative paths like `../components/ui/` without checking if that structure exists
- Creating imports to `IconComponents` or similar UI libraries without verification
- Copying import statements from other files without path verification
- Making changes to import statements without checking current working imports
- Creating duplicate variable declarations in any file
- Using deep relative paths like `../../../services/` instead of `@/services/`
- Creating empty files that break navigation routing
- Leaving files with only whitespace that cause "This screen doesn't exist" errors
- **IMPORTING NEXT.JS PACKAGES IN EXPO PROJECTS** (causes bundling failures)
- **Using @supabase/auth-helpers-nextjs in Expo** (use @supabase/supabase-js instead)
- **Creating API routes like app/api/chat/route.ts** (Next.js pattern, not supported in Expo)
- **Using next/server, next/navigation, or any next/* imports** (Next.js only)
- **Importing createClientComponentClient from auth-helpers-nextjs** (use createClient instead)

#### ‚úÖ REQUIRED ACTIONS:
1. **Before adding any import:**
   ```
   - Use list_dir to check if target directory exists
   - Use file_search to locate the actual component file
   - Use read_file to verify the file has actual content (not empty)
   - Verify the exact relative path from source to target
   ```

2. **For UI component imports specifically:**
   ```
   - Check if components/ui/ directory exists
   - Verify IconComponents.tsx or similar files exist AND have content
   - Use correct path: '@/components/ui/' or './components/ui/' based on project structure
   ```

3. **For existing file modifications:**
   ```
   - Read the current imports in the file first
   - Only modify imports that are already working
   - Never change working import paths without explicit user request
   ```

4. **For variable declarations:**
   ```
   - Always check for existing variable declarations before adding new ones
   - Never declare the same variable name twice in the same scope
   - Use unique variable names or proper scoping
   ```

5. **For service imports:**
   ```
   - ALWAYS use @/ prefix for service imports
   - Correct: import { Service } from '@/services/serviceName'
   - NEVER use: import { Service } from '../../../services/serviceName'
   ```

6. **For Supabase client creation in Expo:**
   ```
   // ‚úÖ CORRECT - Expo/React Native compatible
   import { createClient } from '@supabase/supabase-js';
   const supabase = createClient(
     process.env.EXPO_PUBLIC_SUPABASE_URL!,
     process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!
   );
   
   // ‚ùå FORBIDDEN - Next.js only, causes bundling errors in Expo
   import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
   const supabase = createClientComponentClient();
   ```

7. **For React Native/Expo route files:**
   ```
   - NEVER create empty .tsx files in app/(tabs)/ directory
   - ALWAYS provide complete component implementation
   - Every route file MUST have export default function ComponentName()
   - Verify files have actual content before considering them "created"
   ```

### FILE CORRUPTION PREVENTION

#### Duplicate Declaration Prevention:
```typescript
// ‚ùå BAD - Duplicate variable declarations
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

// Later in same file...
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!; // ERROR!

// ‚úÖ GOOD - Single declaration
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);
```

#### Variable Declaration Best Practices:
1. **Always search for existing declarations** before adding new ones
2. **Use const for immutable values**
3. **Use descriptive, unique variable names**
4. **Avoid global variable pollution**
5. **Never create duplicate const/let/var declarations in same scope**

### REACT INFINITE LOOP PREVENTION

#### üö® CRITICAL: PREVENT USEEFFECT INFINITE LOOPS

These patterns cause "Maximum update depth exceeded" errors:

##### ‚ùå FORBIDDEN Patterns:
```typescript
// BAD - searchParams changes on every render causing infinite loop
const searchParams = useLocalSearchParams();
useEffect(() => {
  // This runs infinitely
}, [searchParams]);

// BAD - Object/array dependencies that change every render
useEffect(() => {
  // This runs infinitely
}, [{ someObj }, [someArray]]);
```

##### ‚úÖ REQUIRED Patterns:
```typescript
// GOOD - Memoize specific values from searchParams
const projectId = useMemo(() => {
  return searchParams?.project_id as string;
}, [searchParams?.project_id]);

useEffect(() => {
  // Prevent multiple calls
  if (alreadyLoaded.current) return;
  alreadyLoaded.current = true;
  
  // Your logic here
  
  return () => {
    alreadyLoaded.current = false; // Reset on cleanup
  };
}, [projectId]);

// GOOD - Use refs for flags to prevent multiple calls
const processStarted = useRef(false);
```

#### Infinite Loop Prevention Rules:
1. **NEVER use raw searchParams or similar objects in useEffect dependencies**
2. **ALWAYS memoize specific values from objects that change frequently**
3. **USE useRef flags to prevent multiple function calls**
4. **ADD cleanup functions to reset flags when dependencies change**
5. **AVOID object literals or array literals in dependency arrays**

### SYNTAX ERROR PREVENTION

#### Critical Syntax Rules:
1. **NEVER leave incomplete code blocks**
2. **ALWAYS close all brackets, parentheses, and braces**
3. **NEVER create orphaned else statements**
4. **CHECK function/method call syntax**
5. **VERIFY all semicolons are placed correctly**
6. **ALWAYS add missing semicolons when required**
7. **NEVER leave malformed if-else structures**

#### Common Syntax Errors to Avoid:
```typescript
// ‚ùå BAD - Missing semicolon
[projectCreatedMessage.id]: projectData.widget!
                                                ^

// ‚úÖ GOOD - Proper semicolon
[projectCreatedMessage.id]: projectData.widget!;

// ‚ùå BAD - Orphaned else
if (condition) {
  // code
} 
// Missing else keyword here
{
  // This creates syntax error
}

// ‚úÖ GOOD - Complete structures
if (condition) {
  // code
} else {
  // alternative code
}

// ‚ùå BAD - Malformed else-if after return
return; // Skip adding regular response text
} else if (toolCall.name === 'create_project') {

// ‚úÖ GOOD - Proper structure
return; // Skip adding regular response text
}
} else if (toolCall.name === 'create_project') {
```

### NEXT.JS VS EXPO COMPATIBILITY

#### üö® CRITICAL: NEVER MIX NEXT.JS AND EXPO PATTERNS

This is an **Expo React Native** project, NOT a Next.js project. The following patterns will cause bundling failures:

##### ‚ùå FORBIDDEN Next.js Patterns:
```typescript
// Next.js Auth Helpers (causes bundling errors)
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';

// Next.js API Routes (not supported in Expo)
// app/api/chat/route.ts - DELETE THIS TYPE OF FILE

// Next.js Server Components
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';

// Next.js Image Component
import Image from 'next/image';
```

##### ‚úÖ REQUIRED Expo Patterns:
```typescript
// Expo-compatible Supabase
import { createClient } from '@supabase/supabase-js';

// Expo Router
import { router } from 'expo-router';

// React Native Image
import { Image } from 'react-native';

// React Native Navigation
import { useNavigation } from '@react-navigation/native';
```

#### Metro Bundler Error Prevention:
1. **Always use standard @supabase/supabase-js for database access**
2. **Never create app/api/ directories or route.ts files**
3. **Use expo-router for navigation, not next/router**
4. **Check package.json - if it has 'expo' dependencies, NO Next.js imports**

### METRO BUNDLER COMPATIBILITY

#### File Extension Rules:
1. **Use .ts for TypeScript files without JSX**
2. **Use .tsx for TypeScript files with JSX**
3. **NEVER mix JSX in .ts files**
4. **Ensure all imports match actual file extensions**

#### Cache Prevention:
1. **After any import path changes, recommend cache clearing**
2. **Watch for Metro cache corruption signs**
3. **Suggest `npx expo start --clear` when bundling issues occur**

### IMPORT PATH MAPPING RULES

#### Preferred Import Patterns:
```typescript
// ‚úÖ GOOD - Use @ prefix for absolute imports
import { Component } from '@/components/Component';
import { Service } from '@/services/Service';
import { Types } from '@/src/types/types';
import { Utils } from '@/utils/utils';

// ‚ùå BAD - Deep relative paths
import { Component } from '../../../components/Component';
import { Service } from '../../../services/Service';
```

#### Service Layer Imports:
```typescript
// ‚úÖ GOOD - Check these paths exist first
import { KnowledgeBucketService } from '@/services/knowledgeBucketService';
import { CoherencyScoreService } from '@/services/coherencyScoreService';

// ‚ùå BAD - Don't assume relative paths work
import { KnowledgeBucketService } from '../../../services/knowledgeBucketService';
```

### EXPO ROUTE FILE REQUIREMENTS

#### React Native Route Files MUST:
1. **Have complete export default function**
2. **Import all necessary React Native components**
3. **Include proper JSX return statement**
4. **Have actual implementation, not empty content**
5. **Be properly formatted TypeScript/React code**

#### Example of CORRECT route file:
```typescript
import React from 'react';
import { View, Text } from 'react-native';

export default function MyScreen() {
  return (
    <View>
      <Text>Screen Content</Text>
    </View>
  );
}
```

#### ‚ùå FORBIDDEN - Empty route files:
```typescript
 
// This causes "This screen doesn't exist" error
```

### VALIDATION CHECKLIST

Before any file edit involving imports or route files:
- [ ] Target file/directory verified to exist
- [ ] Target file verified to have actual content (not empty)
- [ ] Import path tested against file structure  
- [ ] Relative path calculated correctly
- [ ] No assumptions made about UI component availability
- [ ] Existing working imports preserved
- [ ] Metro bundler compatibility considered
- [ ] No duplicate variable declarations
- [ ] Proper variable scoping maintained
- [ ] All syntax structures properly closed
- [ ] Function/method calls properly formatted
- [ ] All semicolons properly placed
- [ ] No orphaned else statements
- [ ] Route files have complete implementations

### IMPORT/EXPORT VERIFICATION RULES

#### Class Constructor Import Errors Prevention:
```typescript
// ‚ùå BAD - Don't assume class exists without verification
import { CoherencyScoreService } from '@/services/coherencyScoreService';
const service = new CoherencyScoreService(); // ERROR: Not a constructor

// ‚úÖ GOOD - Verify class exists first
import { FlowScoreCalculator } from '@/services/coherencyScoreService';
const calculator = new FlowScoreCalculator(); // VERIFIED: Class exists
```

#### Mandatory Import Verification Steps:
1. **Before importing any class:**
   ```
   - Use read_file to check what classes are actually exported
   - Verify the class is exported with 'export class ClassName'
   - Check constructor exists and is accessible
   - Never assume class names based on file names
   ```

2. **Service Import Pattern:**
   ```
   - Read the service file first to see actual exports
   - Use exact exported class names
   - Verify classes have constructors before instantiating
   - Check for default vs named exports
   ```

3. **React Native Component Import Rules:**
   ```
   - Always verify React Native components exist before importing
   - Check for correct export patterns (default vs named)
   - Verify component props and implementation
   ```

### METRO BUNDLER MANDATORY VERIFICATION PROTOCOL

#### BEFORE EVERY SINGLE CODE EDIT:
1. **ALWAYS read target file first** using `read_file` to check current content
2. **ALWAYS verify import paths exist** using `file_search` or `list_dir`
3. **ALWAYS check class exports** before importing with `read_file`
4. **ALWAYS verify route files have complete implementations**

#### CRITICAL IMPORT VERIFICATION RULES:

##### Class Constructor Import Prevention:
```typescript
// ‚ö†Ô∏è MANDATORY: Before importing ANY class, verify it exists:
// 1. Use read_file to check the service file
// 2. Verify exact exported class names
// 3. Check constructor exists and is accessible

// ‚ùå BAD - Don't assume class exists without verification
import { CoherencyScoreService } from '@/services/coherencyScoreService';
const service = new CoherencyScoreService(); // ERROR: Not a constructor

// ‚úÖ GOOD - Verify class exists first
// Step 1: Read services/coherencyScoreService.ts to see actual exports
// Step 2: Use exact exported class names
import { FlowScoreCalculator } from '@/services/coherencyScoreService';
const calculator = new FlowScoreCalculator(); // VERIFIED: Class exists
```

##### Service Import Pattern Verification:
```typescript
// MANDATORY STEPS before importing any service:
// 1. Use read_file to check what classes are actually exported
// 2. Verify the class is exported with 'export class ClassName'
// 3. Check constructor exists and is accessible
// 4. Never assume class names based on file names
```

##### Route File Content Verification:
```typescript
// ‚ùå FORBIDDEN - Empty route files
// File: app/(tabs)/demo.tsx
 
// This causes "This screen doesn't exist" error

// ‚úÖ REQUIRED - Complete route file implementation
import React from 'react';
import { View, Text } from 'react-native';

export default function DemoScreen() {
  return (
    <View>
      <Text>Screen Content</Text>
    </View>
  );
}
```

#### SPECIFIC ERROR PATTERN PREVENTION:

##### 1. Constructor Import Error:
**Error:** `TypeError: X.ClassName is not a constructor`
**Prevention:** 
- Read target file with `read_file` before importing
- Verify exact exported class names
- Check class has accessible constructor
- Never assume class names from filenames

##### 2. Route Content Error:
**Error:** `This screen doesn't exist. Go to home screen!`
**Prevention:**
- Always provide complete component implementation
- Include proper React imports and JSX return
- Verify file has actual content, not just whitespace

##### 3. Import Resolution Error:
**Error:** `Unable to resolve "path" from "file"`
**Prevention:**
- Use `file_search` to verify target file exists
- Check import path against actual directory structure
- Use absolute imports with @ prefix when available

### EMERGENCY PROTOCOL

If user reports bundling errors:
1. **Stop all modifications immediately**
2. **Use read_file** to check the problematic file
3. **Use list_dir** to verify directory structure
4. **Fix import paths** based on actual file locations
5. **Check for and eliminate duplicate declarations**
6. **Verify all syntax structures are complete**
7. **Ensure all route files have actual content**
8. **Fix missing semicolons and malformed structures**
9. **Verify all class imports have correct constructors**
10. **Check export/import patterns match exactly**
11. **Test with minimal changes** before adding complexity
12. **Recommend cache clearing: `rm -rf .expo && rm -rf node_modules/.cache && npx expo start --clear`**

### TYPESCRIPT SYNTAX ENFORCEMENT

#### Required TypeScript Practices:
1. **Proper interface/type definitions**
2. **Correct function signatures**
3. **Proper async/await usage**
4. **Correct export/import statements**
5. **No duplicate variable declarations**
6. **Proper semicolon usage**

#### React Native Specific Rules:
1. **Use React Native components correctly**
2. **Proper StyleSheet usage**
3. **Correct prop typing**
4. **Platform-specific imports when needed**
5. **Complete route file implementations**

### EXPO-SPECIFIC RULES

#### React Native/Expo Import Patterns:
- Use `@expo/vector-icons` for icons, not custom IconComponents unless verified to exist
- Check for existing icon implementations before creating new ones
- Prefer platform-specific imports that are known to work

#### Metro Bundler Considerations:
- Avoid deep relative paths (../../../) that may break during bundling
- Use absolute imports with @ prefix when available
- Check tsconfig.json or similar for path mappings
- Ensure all route files have complete implementations

### MIME TYPE ERROR PREVENTION

#### Server Response Issues:
1. **Watch for Metro returning `application/json` instead of `application/javascript`**
2. **Clear all caches when MIME type errors occur**
3. **Check for syntax errors that could corrupt bundling**
4. **Verify all import paths resolve correctly**
5. **Ensure no duplicate variable declarations causing syntax errors**

### CODE QUALITY ENFORCEMENT

#### Before Every Edit:
1. **Read existing code structure**
2. **Understand current import patterns**
3. **Preserve working configurations**
4. **Test changes incrementally**
5. **Never make assumptions about file locations**
6. **Always verify files have actual content**
7. **Check for duplicate variable declarations**
8. **Verify proper syntax structure completion**

### SPECIFIC ERROR PATTERNS TO AVOID

#### 1. Duplicate Variable Declaration Error:
```
ERROR SyntaxError: Identifier 'supabaseUrl' has already been declared. (7:6)
```
**Prevention:** Always check for existing variable names before declaring new ones

#### 2. Missing Semicolon Error:
```
ERROR SyntaxError: Missing semicolon. (724:48)
```
**Prevention:** Always add semicolons after object property assignments and statements

#### 3. Unexpected Token Error:
```
ERROR SyntaxError: Unexpected token (734:12)
} else if (toolCall.name === 'create_project') {
```
**Prevention:** Ensure proper code block structure and closing braces

#### 4. Route File Content Error:
```
This screen doesn't exist. Go to home screen!
```
**Prevention:** Always provide complete component implementation in route files

#### 5. Constructor Import Error:
```
TypeError: _coherencyScoreService.CoherencyScoreService is not a constructor
```
**Prevention:** 
- Always verify class exports before importing
- Use read_file to check actual exported class names
- Never assume class names from file names
- Verify classes have accessible constructors

## üéØ GOALS: ZERO BUNDLING ERRORS + PERFECT DESIGN CONSISTENCY

Every import must be verified. Every path must be tested. Every variable must be unique. Every syntax structure must be complete. Every route file must have actual content. Never assume file structure. Always verify before modifying.

**Every design must respect existing patterns. Every component must reuse existing ones. Every style must follow the design system. Never create custom designs without research. Always preserve UI/UX consistency.**

### ERROR RECOVERY COMMANDS

When errors occur, run in sequence:
```bash
# 1. Clear all caches
rm -rf .expo
rm -rf node_modules/.cache
rm -rf /tmp/metro-*

# 2. Clear watchman
watchman watch-del-all
watchman shutdown-server

# 3. Kill existing processes
pkill -f "expo start"

# 4. Restart with clean cache
npx expo start --clear --web
```